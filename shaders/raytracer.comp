#version 460 core

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout (rgba32f, binding = 0) uniform image2D imgOutput;
layout (location = 0) uniform float time;

layout (location = 1) uniform mat4 camera_view;
layout (location = 2) uniform bool orthographic;
layout (location = 5) uniform float near_plane;
layout (location = 6) uniform float far_plane;

uint rng_state;
const float PI = 3.14159265f;

#define N_SPHERES 10
#define N_BOUNCES 10
#define N_SAMPLES 10

struct sphere_t {
  vec3 position;
  float radius;
  vec3 color;
};

struct hit_t {
  bool hit;
  vec3 normal;
  vec3 position;
  vec3 color;
};

uint rand_xorshift() {
  rng_state ^= (rng_state << 13);
  rng_state ^= (rng_state >> 17);
  rng_state ^= (rng_state << 5);
  return rng_state;
}

float rand() {
  return float(rand_xorshift()) * (1.0 / 4294967296.0);
}

// https://www.shadertoy.com/view/WttXWX
uint hash_lowbias32(uint x) {
  x ^= x >> 16;
  x *= 0x7feb352dU;
  x ^= x >> 15;
  x *= 0x846ca68bU;
  x ^= x >> 16;
  return x;
}

mat3 get_tangent_space(vec3 normal) {
    vec3 helper = vec3(1, 0, 0);
    if (abs(normal.x) > 0.99f)
        helper = vec3(0, 0, 1);

    vec3 tangent = normalize(cross(normal, helper));
    vec3 binormal = normalize(cross(normal, tangent));
    return mat3(tangent, binormal, normal);
}

// http://three-eyed-games.com/2018/05/12/gpu-path-tracing-in-unity-part-2/
vec3 sample_hemisphere(vec3 normal) {
    // Uniformly sample hemisphere direction
    float cosTheta = rand();
    float sinTheta = sqrt(max(0.0f, 1.0f - cosTheta * cosTheta));
    float phi = 2 * PI * rand();
    vec3 tangent_space_dir = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);
    // Transform direction to world space
    return tangent_space_dir * get_tangent_space(normal);
}


hit_t cast_ray(sphere_t spheres[N_SPHERES], vec3 ray_origin, vec3 ray_direction) {
  vec3 pixel_color = vec3(0.0, 0.0, 0.0);

  float hit_distance = far_plane;
  int sphere_hit_id = -1;
  vec3 normal = vec3(0.0, 0.0, 0.0);
  vec3 hit_position = vec3(0.0, 0.0, 0.0);

  for (int i = 0; i < N_SPHERES; i++) {
    vec4 position = camera_view * vec4(spheres[i].position, 1.0);
    if (!orthographic) {
      position *= -1;
    }

    // Equation for ray hitting a sphere:
    // (ray_origin + ray_direction * t - position)^2 = radius^2
    // O = ray_origin
    // D = ray_direction
    // C = sphere center
    // omc = O - C
    // bsqmc = B^2 - C
    // iff bsqmc >= 0 then there is a hit
    vec3 omc = ray_origin - position.xyz;
    float b = dot(ray_direction, omc);
    float c = dot(omc, omc) - spheres[i].radius * spheres[i].radius;
    float bsqmc = b * b - c;

    if (bsqmc >= 0.0) {
      float t = -b - sqrt(bsqmc);
      if (t > near_plane && t < hit_distance) {
        hit_distance = t;
        sphere_hit_id = i;

        // Calculate the normal of the sphere at the hit point
        normal = normalize(ray_origin + ray_direction * t - position.xyz);
        hit_position = ray_origin + ray_direction * t;
      }
    }
  }

  if (sphere_hit_id >= 0) {
    pixel_color.xyz = spheres[sphere_hit_id].color * dot(normal, (ray_origin - ray_direction));
  }

  hit_t hit = hit_t(
      sphere_hit_id >= 0,
      normal,
      hit_position.xyz,
      pixel_color
      );

  return hit;
}


void main() {
  rng_state = hash_lowbias32(gl_GlobalInvocationID.x * gl_GlobalInvocationID.y + int(mod(time * 1000.0, 10000)));

  vec4 pixel_color = vec4(0.0, 0.0, 0.0, 1.0);
  ivec2 pixel_position = ivec2(gl_GlobalInvocationID.xy);
  ivec2 texture_size = imageSize(imgOutput);

  float aspect_ratio = float(texture_size.x) / float(texture_size.y);
  float max_y = 5.0;
  float max_x = max_y * aspect_ratio;

  float r = 750;
  float f = 11.5;

  sphere_t spheres[N_SPHERES] = {
    //    position            radius  color
    {vec3(  0.0 ,-0.5 , -9.0) , 1.25 , vec3(1.0 , 0.0 , 0.0)} ,
    {vec3(  0.0 , 1.5 , -9.0) , 1.25 , vec3(0.0 , 0.0 , 1.0)} ,
    {vec3(  2.0 , 0.5 ,-11.0) , 2.5  , vec3(1.0 , 1.0 , 1.0)} ,
    {vec3(  0.0 , 0.0 ,-11.0) , 2.5  , vec3(0.3 , 0.8 , 0.2)} ,
    {vec3(  0.0 , 0.0 , 10.0) , 2.5  , vec3(0.4 , 0.2 , 0.8)} ,
    {vec3(  0.0 , 10.0,  0.0) , 2.5  , vec3(0.8 , 0.7 , 0.2)} ,
    {vec3(  0.0 ,-10.0,  0.0) , 2.5  , vec3(0.2 , 0.7 , 0.6)} ,
    {vec3( 10.0,  0.0 ,  0.0) , 2.5  , vec3(0.1 , 0.4 , 0.3)} ,
    {vec3(-10.0,  0.0 ,  0.0) , 2.5  , vec3(0.6 , 0.3 , 0.1)} ,
    {vec3(  0.0 , -r-f,  0.0) , r    , vec3(0.3 , 0.3 , 0.3)} ,
  };

  for (int i_sample = 0; i_sample < N_SAMPLES; i_sample++) {
    // Build a x,y in clip space (ie -1 to 1)
    float x = (float(pixel_position.x * 2 - texture_size.x) / texture_size.x);
    float y = (float(pixel_position.y * 2 - texture_size.y) / texture_size.y);

    // Build a ray from the camera position pointing forward (negative z)
    // Orthographic projection:
    vec3 ray_origin = vec3(x * max_x, y * max_y, 0.0);
    vec3 ray_direction = vec3(0.0, 0.0, -1.0);

    // Perspective projection:
    if (!orthographic) {
      ray_origin = vec3(0.0, 0.0, 0.0);
      ray_direction = normalize(ray_origin - vec3(x * max_x, y * max_y, -10.0));
    }

    for (int i = 0; i < N_BOUNCES; i++) {
      hit_t hit_info = cast_ray(spheres, ray_origin, ray_direction);

      if (!hit_info.hit)
        break;

      pixel_color.xyz += hit_info.color / (N_SAMPLES * N_BOUNCES);
      ray_origin = hit_info.position;
      if (rand() < 0.05)
        ray_direction = reflect(ray_direction, hit_info.normal);
      else
        ray_direction = normalize(sample_hemisphere(hit_info.normal));
    }
  }

  // Gamma correction
  pixel_color.rgb = pow(pixel_color.rgb, vec3(1.0 / 2.2));

  imageStore(imgOutput, pixel_position, pixel_color);
}
