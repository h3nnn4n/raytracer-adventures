#version 460 core

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout (rgba32f, binding = 0) uniform image2D render_texture;
layout (rgba32f, binding = 1) uniform image2D debug_texture;
layout (rgba32f, binding = 2) uniform image2D skybox_texture;

layout (location = 0) uniform float time;

layout (location = 1) uniform mat4 camera_view;
layout (location = 2) uniform bool orthographic;
layout (location = 3) uniform bool incremental_rendering;
layout (location = 5) uniform float near_plane;
layout (location = 6) uniform float far_plane;

layout (location = 7) uniform int n_spheres;

layout (std430, binding = 10) buffer Pos { vec4 positions[]; };
layout (std430, binding = 11) buffer Rad { float radius[]; };
layout (std430, binding = 12) buffer MatType { int material_type[]; };
layout (std430, binding = 13) buffer Col { vec4 albedo[]; };
layout (std430, binding = 14) buffer Rou { float roughness[]; };

uint rng_state;
const float PI = 3.14159265f;

#define N_BOUNCES 5
#define N_SAMPLES 4

struct hit_t {
  bool hit;
  vec3 normal;
  vec3 position;
  int id;
};

uint rand_xorshift() {
  rng_state ^= (rng_state << 13);
  rng_state ^= (rng_state >> 17);
  rng_state ^= (rng_state << 5);
  return rng_state;
}

/***************/
float sinCosRestrain(in float v)
{
    return max(-1.0, min(1.0, v));
}

/*************/
vec2 toSphere(in vec3 v)
{
    float val;
    vec2 o = vec2(1.0);

    float r = sqrt(pow(v.x, 2.0) + pow(v.y, 2.0) + pow(v.z, 2.0));
    val = max(-1.0, min(1.0, v.z / r));
    float theta = acos(val);

    float phi;
    val = v.x / (r * sin(theta));
    float first = acos(sinCosRestrain(val));
    val = v.y / (r * sin(theta));
    float second = asin(sinCosRestrain(val));
    if (second >= 0.0)
        phi = first;
    else
        phi = 2.0 * PI - first;

    o.x = theta * cos(phi);
    o.y = theta * sin(phi);
    o.y /= PI;
    o.x /= PI;

    return o;
}

float rand() {
  return float(rand_xorshift()) * (1.0 / 4294967296.0);
}

vec3 random_vec3() {
  return vec3(rand(), rand(), rand());
}

vec4 random_vec4() {
  return vec4(rand(), rand(), rand(), rand());
}

// https://www.shadertoy.com/view/WttXWX
uint hash_lowbias32(uint x) {
  x ^= x >> 16;
  x *= 0x7feb352dU;
  x ^= x >> 15;
  x *= 0x846ca68bU;
  x ^= x >> 16;
  return x;
}

mat3 get_tangent_space(vec3 normal) {
  vec3 helper = vec3(1, 0, 0);
  if (abs(normal.x) > 0.99f)
    helper = vec3(0, 0, 1);

  vec3 tangent = normalize(cross(normal, helper));
  vec3 binormal = normalize(cross(normal, tangent));
  return mat3(tangent, binormal, normal);
}

// http://three-eyed-games.com/2018/05/12/gpu-path-tracing-in-unity-part-2/
vec3 sample_hemisphere(vec3 normal) {
  // Uniformly sample hemisphere direction
  float cosTheta = rand();
  float sinTheta = sqrt(max(0.0f, 1.0f - cosTheta * cosTheta));
  float phi = 2 * PI * rand();
  vec3 tangent_space_dir = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);
  // Transform direction to world space
  return tangent_space_dir * get_tangent_space(normal);
}

vec3 sample_lambert(vec3 normal) {
  vec3 lambert = normal + random_vec3();

  // Handle degenerate rays
  if (dot(lambert, lambert) < 0.001)
    lambert = normal;

  return normalize(lambert);
}

float length_squared(vec3 v) {
  return dot(v, v);
}

vec3 refract(vec3 ray_direction, vec3 normal, float refraction_ratio) {
  float cos_theta = min(dot(-ray_direction, normal), 1.0);
  vec3 r_out_perp =  refraction_ratio * (ray_direction + normal * cos_theta);
  vec3 r_out_parallel = -sqrt(abs(1.0 - length_squared(r_out_perp))) * normal;
  return r_out_perp + r_out_parallel;
}

hit_t cast_ray(vec3 ray_origin, vec3 ray_direction) {
  float hit_distance = far_plane;
  int sphere_hit_id = -1;
  vec3 normal = vec3(0.0, 0.0, 0.0);
  vec3 hit_position = vec3(0.0, 0.0, 0.0);

  for (int i = 0; i < n_spheres; i++) {
    vec4 position = camera_view * positions[i];
    if (!orthographic) {
      position *= -1;
    }

    // Equation for ray hitting a sphere:
    // (ray_origin + ray_direction * t - position)^2 = radius^2
    // O = ray_origin
    // D = ray_direction
    // C = sphere center
    // omc = O - C
    // bsqmc = B^2 - C
    // iff bsqmc >= 0 then there is a hit
    vec3 omc = ray_origin - position.xyz;
    float b = dot(ray_direction, omc);
    float c = dot(omc, omc) - radius[i]* radius[i];
    float bsqmc = b * b - c;

    if (bsqmc >= 0.0) {
      float t = -b - sqrt(bsqmc);
      if (t > near_plane && t < hit_distance) {
        hit_distance = t;
        sphere_hit_id = i;

        hit_position = ray_origin + ray_direction * t;

        if (int(time * 1.0) % 2 == 0 && false)
          normal = normalize(hit_position - position.xyz);
        else
          normal = normalize(position.xyz - hit_position);
      }
    }
  }

  hit_t hit = hit_t(
    sphere_hit_id >= 0,
    normal,
    hit_position.xyz,
    sphere_hit_id
  );

  return hit;
}


void main() {
  rng_state = hash_lowbias32(gl_GlobalInvocationID.x * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x + int(mod(time * 100000.0, 100000000)));

  vec4 pixel_color = vec4(0.0, 0.0, 0.0, 1.0);
  ivec2 pixel_position = ivec2(gl_GlobalInvocationID.xy);
  ivec2 texture_size = imageSize(render_texture);
  vec2 pixel_size = vec2(1.0 / float(texture_size.x), 1.0 / float(texture_size.y));
  vec4 old_color = imageLoad(render_texture, pixel_position);
  imageStore(debug_texture, pixel_position, vec4(0.0, 0.0, 0.0, 1.0));

  float aspect_ratio = float(texture_size.x) / float(texture_size.y);
  float max_y = 5.0;
  float max_x = max_y * aspect_ratio;

  for (int i_sample = 0; i_sample < N_SAMPLES; i_sample++) {
    // Build a x,y in clip space (ie -1 to 1)
    float x = (float(pixel_position.x * 2 - texture_size.x) / texture_size.x);
    float y = (float(pixel_position.y * 2 - texture_size.y) / texture_size.y);

    // Apply antialiasing noise
    x += rand() * pixel_size.x;
    y += rand() * pixel_size.y;

    // Build a ray from the camera position pointing forward (negative z)
    // Orthographic projection:
    vec3 ray_origin = vec3(x * max_x, y * max_y, 0.0);
    vec3 ray_direction = vec3(0.0, 0.0, -1.0);

    // Perspective projection:
    if (!orthographic) {
      ray_origin = vec3(0.0, 0.0, 0.0);
      ray_direction = normalize(ray_origin - vec3(x * max_x, y * max_y, -10.0));
    }

    vec4 result        = vec4(0.0, 0.0, 0.0, 0.0);
    vec3 ambient_light = vec3(0.0, 0.0, 0.0);
    //ambient_light      = vec3(0.1, 0.1, 0.1);
    result.rgb = ambient_light;

    for (int i = 0; i < N_BOUNCES; i++) {
      hit_t hit_info = cast_ray(ray_origin, ray_direction);

      if (!hit_info.hit) {
        result.rgb *= ambient_light;
        break;
      }

      // I am not convinced by this
      ray_origin = hit_info.position + hit_info.normal * 0.001;
      ray_origin = hit_info.position;

      int material_type = material_type[hit_info.id];
      if (material_type == 1) {
        // Diffuse
        result.rgb *= albedo[hit_info.id].rgb * dot(hit_info.normal, ray_direction);
        //result.rgb = albedo[hit_info.id].rgb;
        ray_direction = sample_hemisphere(hit_info.normal);
        ray_direction = sample_lambert(hit_info.normal);

        imageStore(debug_texture, pixel_position, vec4(hit_info.normal * 0.5 + 0.5, 1.0));
      } else if (material_type == 2) {
        // Metal
        result.rgb *= albedo[hit_info.id].rgb;
        ray_direction = reflect(ray_direction, hit_info.normal);
        vec3 fuzz = random_vec3() * roughness[hit_info.id];

        // Make sure that the fuzz doesn't push the ray inside the object at glancing angles
        if (dot(fuzz, hit_info.normal) < 0.0)
          fuzz = -fuzz;

        ray_direction = normalize(ray_direction + fuzz);
      } else if (material_type == 3) {
        // Dieletrics

        // When the ray gets refracted, we just pass it through the object with
        // changing the color
        result.rgb *= vec3(1.0, 1.0, 1.0);

        // TODO: Make the refraction ratio a property of the material
        float refraction_ratio = 1.5;

        // This might be backwards
        if (dot(ray_direction, hit_info.normal) < 0.0)
          refraction_ratio = 1.0 / refraction_ratio;

        // TODO: Implement reflections
        // TODO: Implement total internal reflection
        vec3 refracted = refract(normalize(ray_origin - ray_direction), hit_info.normal, refraction_ratio);
        ray_direction = refracted;
        //result.rgb = refracted * 0.5 + 0.5;
        //break;
      } else if (material_type < 4) {
        // Whatever
        result.rgb *= albedo[hit_info.id].rgb;
        ray_direction = sample_lambert(hit_info.normal);
      } else if (material_type == 5) {
        // Light
        result.rgb += albedo[hit_info.id].rgb;

        imageStore(debug_texture, pixel_position, vec4(hit_info.normal * 0.5 + 0.5, 1.0));
        // After a ray hits a light, it stops there (since the ray is actually
        // going backwards, it means that the ray started at the light and
        // ended at the camera)
        break;
      }
    }

    pixel_color.rgb += clamp(result.rgb, 0.0, 1.0) / float(N_SAMPLES);
    //imageStore(debug_texture, pixel_position, vec4(ray_direction * 0.5 + 0.5, 1.0));
    //imageStore(debug_texture, pixel_position, vec4(x, y, 0, 1));

    //vec3 ray = normalize(ray_origin - ray_direction);
    //vec3 ray = normalize(ray_direction - ray_origin);
    vec3 ray = normalize(camera_view * vec4(ray_direction, 1.0)).xyz;
    //vec3 ray = normalize(ray_origin);

    //float theta = acos(ray.y) / PI;
    //float phi = (atan(ray.x, -ray.z) * 2.0) / PI * 0.5f;
    //pixel_color = vec4(theta, phi, 0, 1);
    //pixel_color.r = 0;
    //pixel_color = imageLoad(skybox_texture, ivec2((vec2(theta, phi)) * vec2(texture_size)));
    //pixel_color = imageLoad(skybox_texture, ivec2((vec2(x, y) + 1.0) * vec2(texture_size)));
    //vec2 sky_pos = (vec2(x, y) + 1.0) * vec2(texture_size);
    vec2 sky_pos = (toSphere(ray) + 1.0) * vec2(4096, 2048);
    imageStore(debug_texture, pixel_position, imageLoad(skybox_texture, ivec2(sky_pos)));
    //pixel_color = imageLoad(skybox_texture, ivec2(sky_pos));
  }

  vec4 final_color = vec4((old_color + pixel_color).rgb, old_color.a + 1);
  if (time < 0.1 || !incremental_rendering)
    final_color = pixel_color;

  //imageStore(debug_texture, pixel_position, imageLoad(skybox_texture, pixel_position));
  //imageStore(render_texture, pixel_position, imageLoad(skybox_texture, pixel_position));
  imageStore(render_texture, pixel_position, final_color);
}
