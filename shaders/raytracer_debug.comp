#version 460 core

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout (rgba32f, binding = 0) uniform image2D render_texture;
layout (rgba32f, binding = 1) uniform image2D debug_texture;
layout (rgba32f, binding = 2) uniform image2D skybox_texture;

layout (location = 0) uniform float time;

layout (location = 1) uniform mat4 camera_view;
layout (location = 2) uniform bool orthographic;
layout (location = 3) uniform bool incremental_rendering;
layout (location = 5) uniform float near_plane;
layout (location = 6) uniform float far_plane;
layout (location = 7) uniform int rng_seed;

layout (location = 9) uniform int n_spheres;

layout (std430, binding = 10) buffer Pos { vec4 positions[]; };
layout (std430, binding = 11) buffer Rad { float radius[]; };
layout (std430, binding = 12) buffer MatType { int material_type[]; };
layout (std430, binding = 13) buffer Col { vec4 albedo[]; };
layout (std430, binding = 14) buffer Rou { float roughness[]; };

uint rng_state;
const float PI = 3.14159265f;

#define N_BOUNCES 10
#define N_SAMPLES 10

struct hit_t {
  bool hit;
  vec3 normal;
  vec3 position;
  int id;
};

uint rand_xorshift() {
  rng_state ^= (rng_state << 13);
  rng_state ^= (rng_state >> 17);
  rng_state ^= (rng_state << 5);
  return rng_state;
}


float rand() {
  return float(rand_xorshift()) / 4294967296.0;
}

vec3 random_vec3() {
  return vec3(rand(), rand(), rand()) * 2.0 - 1.0;
}

vec4 random_vec4() {
  return vec4(rand(), rand(), rand(), rand()) * 2.0 - 1.0;
}

// https://www.shadertoy.com/view/WttXWX
uint hash_lowbias32(uint x) {
  x ^= x >> 16;
  x *= 0x7feb352dU;
  x ^= x >> 15;
  x *= 0x846ca68bU;
  x ^= x >> 16;
  return x;
}

vec3 sample_lambert(vec3 normal) {
  vec3 lambert = normal + random_vec3();

  // Handle degenerate rays
  if (dot(lambert, lambert) < 0.001)
    lambert = normal;

  return normalize(lambert);
}

float length_squared(vec3 v) {
  return dot(v, v);
}

vec3 refract(vec3 ray_direction, vec3 normal, float refraction_ratio) {
  float cos_theta = min(dot(-ray_direction, normal), 1.0);
  vec3 r_out_perp =  refraction_ratio * (ray_direction + normal * cos_theta);
  vec3 r_out_parallel = -sqrt(abs(1.0 - length_squared(r_out_perp))) * normal;
  return r_out_perp + r_out_parallel;
}

hit_t cast_ray(vec3 ray_origin, vec3 ray_direction) {
  float hit_distance = far_plane;
  int sphere_hit_id = -1;
  vec3 normal = vec3(0.0, 0.0, 0.0);
  vec3 hit_position = vec3(0.0, 0.0, 0.0);

  for (int i = 0; i < n_spheres; i++) {
    vec4 position = camera_view * positions[i];

    // Equation for ray hitting a sphere:
    // (ray_origin + ray_direction * t - position)^2 = radius^2
    // O = ray_origin
    // D = ray_direction
    // C = sphere center
    // omc = O - C
    // bsqmc = B^2 - C
    // iff bsqmc >= 0 then there is a hit
    vec3 omc = ray_origin - position.xyz;
    float b = dot(ray_direction, omc);
    float c = dot(omc, omc) - radius[i]* radius[i];
    float bsqmc = b * b - c;

    if (bsqmc >= 0.0) {
      float t = -b - sqrt(bsqmc);
      if (t >= near_plane && t <= hit_distance) {
        hit_distance = t;
        sphere_hit_id = i;

        hit_position = ray_origin + ray_direction * t;

        normal = normalize(hit_position - position.xyz);
      } else {
        t = -b + sqrt(bsqmc);
        if (t >= near_plane && t <= hit_distance) {
          hit_distance = t;
          sphere_hit_id = i;

          hit_position = ray_origin + ray_direction * t;

          normal = normalize(hit_position - position.xyz);
        }
      }
    }
  }

  hit_t hit = hit_t(
    sphere_hit_id >= 0,
    normal,
    hit_position.xyz,
    sphere_hit_id
  );

  return hit;
}

void main() {
  rng_state = hash_lowbias32(gl_GlobalInvocationID.x * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x + rng_seed);

  vec4 pixel_color = vec4(0.0, 0.0, 0.0, 1.0);
  ivec2 pixel_position = ivec2(gl_GlobalInvocationID.xy);
  ivec2 texture_size = imageSize(render_texture);
  vec2 pixel_size = vec2(1.0 / float(texture_size.x), 1.0 / float(texture_size.y));
  vec4 old_color = imageLoad(render_texture, pixel_position);
  imageStore(debug_texture, pixel_position, vec4(0.0, 0.0, 0.0, 1.0));

  float aspect_ratio = float(texture_size.x) / float(texture_size.y);
  float max_y = 5.0;
  float max_x = max_y * aspect_ratio;

  for (int i_sample = 0; i_sample < N_SAMPLES; i_sample++) {
    // Build a x,y in clip space (ie -1 to 1)
    float x = (float(pixel_position.x * 2 - texture_size.x) / texture_size.x);
    float y = (float(pixel_position.y * 2 - texture_size.y) / texture_size.y);

    // Apply antialiasing noise
    x += rand() * pixel_size.x;
    y += rand() * pixel_size.y;

    vec3 ray_origin    = vec3(0.0, 0.0, 0.0);
    vec3 ray_direction = normalize(ray_origin + vec3(x * max_x, y * max_y, -10.0));
    vec4 result        = vec4(1.0, 1.0, 1.0, 0.0);

    for (int i = 0; i < N_BOUNCES; i++) {
      hit_t hit_info = cast_ray(ray_origin, ray_direction);

      if (!hit_info.hit) {
        float t = 0.5 * (ray_direction.y + 1.0);
        vec3 sky_color = (1.0 - t) * vec3(1.0) + t * vec3(0.5, 0.7, 1.0);
        result.rgb *= sky_color;
        break;
      }
      int material_type = material_type[hit_info.id];
      if (material_type == 1) {
        // Diffuse Material
        //
        // FIXME: No idea what is going on with the cossine rule here. Maybe
        // missing the camera view matrix? Feels super weird to need to invert
        // the normal around.
        result.rgb *= albedo[hit_info.id].rgb * dot(-hit_info.normal, ray_direction);
        ray_direction = sample_lambert(hit_info.normal);

        if (i == 0) {
          vec4 normal_color = vec4(hit_info.normal * 0.5 + 0.5, 1.0);
          imageStore(debug_texture, pixel_position, normal_color);
        }
      } else if (material_type == 2) {
        // Metal
        result.rgb *= albedo[hit_info.id].rgb;
        ray_direction = reflect(ray_direction, hit_info.normal);
        vec3 fuzz = random_vec3() * roughness[hit_info.id];

        // Make sure that the fuzz doesn't push the ray inside the object at glancing angles
        if (dot(fuzz, hit_info.normal) < 0.0)
          fuzz = -fuzz;

        ray_direction = normalize(ray_direction + fuzz);
      } else if (material_type == 3) {
        // Dieletric Material

        // NOTE: Not sure if it makes sense for a glass material to have an
        // albedo. There are colored glasses in real life, so maybe?
        result.rgb *= albedo[hit_info.id].rgb;
        vec3 normal = hit_info.normal;

        // TODO: Make the refraction ratio a property of the material
        float refraction_ratio = 1.5;

        if (dot(ray_direction, hit_info.normal) > 0.0) {
          normal = -normal;
        } else {
          refraction_ratio = 1.0 / refraction_ratio;
        }

        // TODO: Implement reflections
        // TODO: Implement total internal reflection
        vec3 refracted = refract(normalize(ray_direction), normal, refraction_ratio);
        ray_direction = refracted;
      } else if (material_type < 4) {
        // Whatever
        result.rgb *= albedo[hit_info.id].rgb;
        ray_direction = sample_lambert(hit_info.normal);
      } else if (material_type == 5) {
        // Light
        result.rgb += albedo[hit_info.id].rgb;

        imageStore(debug_texture, pixel_position, vec4(hit_info.normal * 0.5 + 0.5, 1.0));
        // After a ray hits a light, it stops there (since the ray is actually
        // going backwards, it means that the ray started at the light and
        // ended at the camera)
        break;
      }

      ray_origin = hit_info.position + hit_info.normal * 0.001;
    }

    pixel_color.rgb += (result.rgb) / float(N_SAMPLES);
  }

  vec4 final_color = vec4((old_color + pixel_color).rgb, old_color.a + 1);
  if (time < 0.1 || !incremental_rendering)
    final_color = pixel_color;

  imageStore(render_texture, pixel_position, final_color);
}
